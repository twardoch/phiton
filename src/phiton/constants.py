#!/usr/bin/env -S uv run -s
# /// script
# dependencies = []
# ///
# this_file: src/phiton/constants.py

"""Constants and symbol mappings for Phiton conversion."""

# Symbol mappings for Python to Phiton conversion
PYTHON_TO_PHITON = {
    # Control Flow
    "return": "â‡",
    "yield": "â†¥",
    "yield from": "â†¥â‹®",
    "raise": "â†‘",
    "while": "âŸ³",
    "for": "âˆ€",
    "if": "â‹”",
    "else": "â‹®",
    "try": "âšŸ",
    "match": "â†¦",
    "case": "â‰",
    "assert": "âŠª",
    "pass": "âŠ˜",
    "continue": "â‹¯",
    "break": "âŠ ",
    # Data Operations
    "=": "â‰”",
    "==": "â‰¡",
    "!=": "â‰ ",
    "in": "âˆˆ",
    "not in": "âˆ‰",
    "sum": "âˆ‘",
    "map": "âˆ«",
    "reduce": "â¨",
    "+=": "â–³",
    "-=": "â–½",
    "*=": "â—Š",
    "/=": "â—†",
    ":=": "â‰",
    "<=": "â‰¤",
    ">=": "â‰¥",
    "and": "âˆ§",
    "or": "âˆ¨",
    "not": "Â¬",
    # Special Values
    "None": "âˆ…",
    "True": "âŠ¤",
    "False": "âŠ¥",
    "...": "â‹®",
    # Objects & Functions
    "def": "Æ’",
    "lambda": "Î»",
    "class": "Î£",
    "@property": "âŠ™",
    "async": "âŠ¡",
    "await": "âŠ¡",
    "@staticmethod": "âŠ",
    "@classmethod": "âŠŸ",
    "@abstractmethod": "âŸ",
    "@dataclass": "â›‹",
    # New Additions
    "len": "â„“",
    "range": "â„œ",
    "enumerate": "â„¯",
    "filter": "Ï†",
    "zip": "â„¤",
    "sorted": "Ï‚",
    "reversed": "â„›",
    "any": "âˆƒ",
    "all": "âˆ€",
    "min": "â†“",
    "max": "â†‘",
    "round": "â—‹",
    "abs": "âˆ¥",
    "pow": "^",
    "isinstance": "âˆ‹",
    "hasattr": "âˆŒ",
    "getattr": "âŠ³",
    "setattr": "âŠ²",
    "delattr": "âŠ—",
    "super": "â†°",
    "next": "â†’",
    "iter": "âŸ²",
}

# Reverse mapping for Phiton to Python conversion
PHITON_TO_PYTHON = {v: k for k, v in PYTHON_TO_PHITON.items()}

# Add more symbol mappings for domain-specific operations
DOMAIN_PREFIXES = {
    "numpy": "â„–",
    "pandas": "â„—",
    "sklearn": "Ï‡",
    "matplotlib": "Î¼",
    "torch": "Î¨",
    "tensorflow": "Î¦",
    "flask": "Ï†",
    "django": "É—",
    "fastapi": "Ï±",
    "os": "Î±",
    "io": "Î©",
    "typing": "Ï„",
    "math": "Î”",
    "collections": "Î“",
    "itertools": "Î›",
    "datetime": "Î˜",
    "sqlalchemy": "Î¶",
    "requests": "Î·",
    "json": "Î¾",
    "pathlib": "Ï€",
    "re": "Â®",
    # New additions
    "asyncio": "Î³",
    "functools": "Ï",
    "operator": "Ï‰",
    "random": "Ï",
    "string": "Ïƒ",
    "sys": "Ïˆ",
    "time": "Î¸",
    "uuid": "Ï…",
    "yaml": "Ï’",
    "zlib": "Î¶",
}

# Common pattern replacements
PATTERN_REPLACEMENTS = {
    "if x is not None": "â‹”xâ‰ âˆ…",
    "if x is None": "â‹”xâ‰¡âˆ…",
    "for i in range(n)": "âˆ€iâˆˆâ„œ(n)",
    "for i, x in enumerate(xs)": "âˆ€i,xâˆˆâ„¯(xs)",
    "return [x for x in xs if p(x)]": "â‡[xâˆ€xâˆˆxsâ‹”p(x)]",
    "lambda x: f(x)": "Î»xâ‡’f(x)",
    "with open(f) as h": "âŠ¢âŠ£âŠ—(f)â‡’h",
    "try: x\nexcept E: y": "âšŸâŸ¨xâŸ©â‹”EâŸ¨yâŸ©",
    "if p: return x": "â‹”pâ‡x",
    "if not p: return": "â‹”Â¬pâ‡",
    "x if p else y": "p?x:y",
    "[f(x) for x in xs]": "âˆ«(f,xs)",
    "sum(x for x in xs)": "âˆ‘(xs)",
    "all(p(x) for x in xs)": "âˆ€(p,xs)",
    "any(p(x) for x in xs)": "âˆƒ(p,xs)",
}

# Add advanced pattern recognition
ADVANCED_PATTERNS = {
    # Common function chains
    "df.groupby(X).agg(Y)": "Â§dfÂ·Î“(X)Â·A(Y)",
    "df.sort_values(by=X,ascending=Y)": "Â§dfÂ·Ï‚(X,Y)",
    "np.array(X).reshape(Y)": "â„–Â·A(X)Â·R(Y)",
    "pd.DataFrame(X).reset_index()": "â„—Â·D(X)Â·R()",
    "pd.read_csv(X,encoding=Y)": "â„—Â·C(X,Y)",
    "requests.get(X).json()": "Î·Â·G(X)Â·J()",
    # Common list/dict operations
    "[x for x in X if C]": "[xâˆ€xâˆˆXâ‹”C]",
    "{k:v for k,v in X.items()}": "{k:vâˆ€k,vâˆˆXÂ·âŠ™}",
    "dict((k,v) for k,v in X)": "âˆ‚(X)",
    "list(map(F, X))": "âˆ«(F,X)",
    "list(filter(F, X))": "Ï†(F,X)",
    "[i for i,x in enumerate(X) if P]": "[iâˆ€i,xâˆˆâ„¯(X)â‹”P]",
    "next(x for x in X if P)": "â†’(xâˆ€xâˆˆXâ‹”P)",
    "any(x in Y for x in X)": "âˆƒ(xâˆˆYâˆ€xâˆˆX)",
    "all(x in Y for x in X)": "âˆ€(xâˆˆYâˆ€xâˆˆX)",
    "{x: y for x,y in zip(X,Y)}": "{x:yâˆ€x,yâˆˆâ„¤(X,Y)}",
    "sorted(X, key=lambda x: x.Y)": "Ï‚(X,Î»x:xÂ·Y)",
    "max(X, key=lambda x: x.Y)": "â†‘(X,Î»x:xÂ·Y)",
    "min(X, key=lambda x: x.Y)": "â†“(X,Î»x:xÂ·Y)",
    # Common control flow patterns
    "if x is not None: return x\nelse: return y": "â‡xâ‰¢âˆ…?x:y",
    "try:\n    x\nexcept E as e:\n    y": "âšŸâŸ¨xâŸ©â‹”Eâ‡’eâŸ¨yâŸ©",
    "with contextlib.suppress(E):": "âŠ¢âŠ£âˆ…(E)âŸ¨",
    "if not x: return": "â‹”Â¬xâ‡",
    "if not x: continue": "â‹”Â¬xâ‹¯",
    "if not x: break": "â‹”Â¬xâŠ ",
    "while True: x": "âŸ³âŠ¤âŸ¨xâŸ©",
    "if x and y: z": "â‹”xâˆ§yâŸ¨zâŸ©",
    "if x or y: z": "â‹”xâˆ¨yâŸ¨zâŸ©",
    # Common async patterns
    "async with aiohttp.ClientSession() as session:": "âŠ¢âŠ£âŠ¡Î·Â·S()â‡’sâŸ¨",
    "await asyncio.gather(*tasks)": "âŠ¡Î³Â·G(â—‡t)",
    "async for x in Y:": "âŠ¡âˆ€xâˆˆYâŸ¨",
    "await asyncio.sleep(X)": "âŠ¡Î³Â·S(X)",
    "await asyncio.create_task(X)": "âŠ¡Î³Â·T(X)",
    # Common string operations
    "'.'.join(x for x in X)": "Â·âŠ•(X)",
    "x.strip().lower()": "xÂ·âŒ¿Â·â†“",
    "re.sub(P, R, S)": "Â®Â·â‡Œ(P,R,S)",
    "x.split()": "xÂ·âŒ¿",
    "x.replace(Y, Z)": "xÂ·â‡Œ(Y,Z)",
    "f'{x}{y}'": "ã€Œxã€ã€Œyã€",
    "x.startswith(Y)": "xÂ·âŠ³Y",
    "x.endswith(Y)": "xÂ·âŠ²Y",
    # Common math operations
    "math.floor(x/y)": "âŒŠx/yâŒ‹",
    "math.ceil(x/y)": "âŒˆx/yâŒ‰",
    "abs(x-y)": "âˆ¥x-yâˆ¥",
    "pow(x, y)": "x^y",
    "math.sqrt(x)": "âˆšx",
    "math.pi": "Ï€",
    "math.e": "â„¯",
    "float('inf')": "âˆ",
    "float('-inf')": "-âˆ",
    # Common type checking
    "isinstance(x, (A, B))": "xâˆ‹(A,B)",
    "hasattr(x, 'y')": "xâˆŒ'y'",
    "getattr(x, 'y', d)": "xâŠ³'y'â‹®d",
    "type(x) is Y": "Ï„(x)â‰¡Y",
    "type(x) == Y": "Ï„(x)â‰¡Y",
    # Common file operations
    "with open(X, 'r') as f:": "âŠ¢âŠ£âŠ—(X,'r')â‡’fâŸ¨",
    "with open(X, 'w') as f:": "âŠ¢âŠ£âŠ—(X,'w')â‡’fâŸ¨",
    "os.path.join(X, Y)": "Î±Â·âŠ•(X,Y)",
    "os.path.exists(X)": "Î±Â·âˆƒ(X)",
    "os.path.dirname(X)": "Î±Â·âˆ‚(X)",
    "os.path.basename(X)": "Î±Â·Î²(X)",
    # Common collections operations
    "collections.defaultdict(list)": "Î“Â·âˆ‚(â„“)",
    "collections.Counter(X)": "Î“Â·C(X)",
    "collections.deque(X)": "Î“Â·Q(X)",
    "itertools.chain(*X)": "Î›Â·âŠ•(â—‡X)",
    "itertools.cycle(X)": "Î›Â·âŸ³(X)",
    "itertools.repeat(X, n)": "Î›Â·â„œ(X,n)",
    # Common testing patterns
    "assert x == y": "âŠªxâ‰¡y",
    "assert x is not None": "âŠªxâ‰¢âˆ…",
    "assert isinstance(x, Y)": "âŠªxâˆ‹Y",
    "assert len(x) > 0": "âŠªâ„“(x)>0",
    "assert all(x in Y for x in X)": "âŠªâˆ€(xâˆˆYâˆ€xâˆˆX)",
    # Common error handling
    "raise ValueError(X)": "â†‘V(X)",
    "raise TypeError(X)": "â†‘T(X)",
    "raise Exception(X)": "â†‘E(X)",
    "raise NotImplementedError": "â†‘âˆ…",
    # Common functional patterns
    "functools.partial(F, X)": "ÏÂ·P(F,X)",
    "functools.reduce(F, X)": "ÏÂ·R(F,X)",
    "operator.itemgetter(X)": "Ï‰Â·I(X)",
    "operator.attrgetter(X)": "Ï‰Â·A(X)",
    # Common datetime operations
    "datetime.datetime.now()": "Î˜Â·N()",
    "datetime.datetime.utcnow()": "Î˜Â·U()",
    "datetime.timedelta(days=X)": "Î˜Â·D(X)",
    "datetime.datetime.strptime(X,Y)": "Î˜Â·P(X,Y)",
    "datetime.datetime.strftime(X,Y)": "Î˜Â·F(X,Y)",
}

# Add final compression optimizations
COMMON_SUBEXPRESSIONS = {
    # Common numeric operations
    "x + 1": "xâº",
    "x - 1": "xâ»",
    "x * 2": "xÂ²",
    "x ** 2": "xÂ²",
    "x ** 3": "xÂ³",
    "x ** n": "xâ¿",
    "x / 2": "xÂ½",
    # Common string operations
    ".split()": "Â·âŒ¿",
    ".strip()": "Â·âŒ¿",
    ".lower()": "Â·â†“",
    ".upper()": "Â·â†‘",
    ".replace(": "Â·â‡Œ(",
    ".format(": "Â·â¨(",
    ".join(": "Â·âŠ•(",
    # Common list operations
    ".append(": "Â·âŠ•(",
    ".extend(": "Â·âŠ•âŠ•(",
    ".pop(": "Â·âŠ–(",
    ".clear(": "Â·âˆ…(",
    ".copy(": "Â·âŠ™(",
    ".sort(": "Â·Ï‚(",
    ".reverse(": "Â·â„›(",
    # Common dict operations
    ".keys()": "Â·âŠ™",
    ".values()": "Â·âŠš",
    ".items()": "Â·âŠ›",
    ".get(": "Â·âŠ³(",
    ".update(": "Â·âŠ²(",
    # Common type conversions
    "str(": "Ïƒ(",
    "int(": "â„¤(",
    "float(": "â„(",
    "bool(": "ğ”¹(",
    "list(": "â„“(",
    "tuple(": "Ï„(",
    "dict(": "âˆ‚(",
    "set(": "ğ•Š(",
}
