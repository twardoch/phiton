"""
    Document360 Customer API

    Document360 RESTful APIs will allow you to integrate your documentation with your software, allowing you to easily onboard new users, manage your articles and more.   You can find detailed API documentation here : [API Documentation](https://apidocs.document360.io/docs)

    The version of the OpenAPI document: 2.0
    Contact: support@document360.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""

import warnings
from typing import Annotated, Any

from d361api.api_client import ApiClient, RequestSerialized
from d361api.api_response import ApiResponse
from d361api.models.bulk_create_article_response_customer import \
    BulkCreateArticleResponseCustomer
from d361api.models.bulk_delete_article_response import \
    BulkDeleteArticleResponse
from d361api.models.bulk_delete_article_version_resonse import \
    BulkDeleteArticleVersionResonse
from d361api.models.bulk_publish_article import BulkPublishArticle
from d361api.models.bulk_update_article import BulkUpdateArticle
from d361api.models.bulk_update_article_response import \
    BulkUpdateArticleResponse
from d361api.models.create_article_request import CreateArticleRequest
from d361api.models.create_article_response import CreateArticleResponse
from d361api.models.customer_api_base_response import CustomerApiBaseResponse
from d361api.models.fork_article_version_request import \
    ForkArticleVersionRequest
from d361api.models.fork_article_version_response import \
    ForkArticleVersionResponse
from d361api.models.get_article_response_customer import \
    GetArticleResponseCustomer
from d361api.models.get_article_settings_response import \
    GetArticleSettingsResponse
from d361api.models.get_article_version_response import \
    GetArticleVersionResponse
from d361api.models.get_article_versions_response import \
    GetArticleVersionsResponse
from d361api.models.publish_article_request import PublishArticleRequest
from d361api.models.update_article_request import UpdateArticleRequest
from d361api.models.update_article_settings_request import \
    UpdateArticleSettingsRequest
from d361api.models.update_article_settings_response_customer import \
    UpdateArticleSettingsResponseCustomer
from d361api.rest import RESTResponseType
from pydantic import (Field, StrictBool, StrictFloat, StrictInt, StrictStr,
                      validate_call)


class ArticlesApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    async def v2_articles_article_id_delete(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CustomerApiBaseResponse:
        """Deletes an article with an ID


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_article_id_delete_serialize(
            article_id=article_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CustomerApiBaseResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def v2_articles_article_id_delete_with_http_info(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CustomerApiBaseResponse]:
        """Deletes an article with an ID


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_article_id_delete_serialize(
            article_id=article_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CustomerApiBaseResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def v2_articles_article_id_delete_without_preload_content(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Deletes an article with an ID


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_article_id_delete_serialize(
            article_id=article_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CustomerApiBaseResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_articles_article_id_delete_serialize(
        self,
        article_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if article_id is not None:
            _path_params["articleId"] = article_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                [
                    "application/json"
                ]
            )


        # authentication setting
        _auth_settings: list[str] = [
            "api_token"
        ]

        return self.api_client.param_serialize(
            method="DELETE",
            resource_path="/v2/Articles/{articleId}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def v2_articles_article_id_fork_put(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        fork_article_version_request: ForkArticleVersionRequest | None = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ForkArticleVersionResponse:
        """Forks an article with an id


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param fork_article_version_request: 
        :type fork_article_version_request: ForkArticleVersionRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_article_id_fork_put_serialize(
            article_id=article_id,
            fork_article_version_request=fork_article_version_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "ForkArticleVersionResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def v2_articles_article_id_fork_put_with_http_info(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        fork_article_version_request: ForkArticleVersionRequest | None = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ForkArticleVersionResponse]:
        """Forks an article with an id


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param fork_article_version_request: 
        :type fork_article_version_request: ForkArticleVersionRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_article_id_fork_put_serialize(
            article_id=article_id,
            fork_article_version_request=fork_article_version_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "ForkArticleVersionResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def v2_articles_article_id_fork_put_without_preload_content(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        fork_article_version_request: ForkArticleVersionRequest | None = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Forks an article with an id


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param fork_article_version_request: 
        :type fork_article_version_request: ForkArticleVersionRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_article_id_fork_put_serialize(
            article_id=article_id,
            fork_article_version_request=fork_article_version_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "ForkArticleVersionResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_articles_article_id_fork_put_serialize(
        self,
        article_id,
        fork_article_version_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if article_id is not None:
            _path_params["articleId"] = article_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if fork_article_version_request is not None:
            _body_params = fork_article_version_request


        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                [
                    "application/json"
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        "application/json-patch+json",
                        "application/json",
                        "text/json",
                        "application/*+json"
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: list[str] = [
            "api_token"
        ]

        return self.api_client.param_serialize(
            method="PUT",
            resource_path="/v2/Articles/{articleId}/fork",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def v2_articles_article_id_lang_code_get(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        lang_code: Annotated[StrictStr, Field(description="Language code of the article")],
        is_for_display: Annotated[StrictBool | None, Field(description="Set this to true, if you are displaying the article to the end-user. If true, the content of snippets or variables appears in the article. Note: If the value is true, ensure that the article content is not passed for update article endpoints.")] = None,
        is_published: Annotated[StrictBool | None, Field(description="**true** : You will get the latest published version of the article. (If there are no published versions, then it will return the latest version)              **false** : To get the the latest version of the article")] = None,
        append_sas_token: Annotated[StrictBool | None, Field(description="Set this to false to exclude appending SAS token for images/files")] = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetArticleResponseCustomer:
        """Gets an article


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param lang_code: Language code of the article (required)
        :type lang_code: str
        :param is_for_display: Set this to true, if you are displaying the article to the end-user. If true, the content of snippets or variables appears in the article. Note: If the value is true, ensure that the article content is not passed for update article endpoints.
        :type is_for_display: bool
        :param is_published: **true** : You will get the latest published version of the article. (If there are no published versions, then it will return the latest version)              **false** : To get the the latest version of the article
        :type is_published: bool
        :param append_sas_token: Set this to false to exclude appending SAS token for images/files
        :type append_sas_token: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_article_id_lang_code_get_serialize(
            article_id=article_id,
            lang_code=lang_code,
            is_for_display=is_for_display,
            is_published=is_published,
            append_sas_token=append_sas_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "GetArticleResponseCustomer",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def v2_articles_article_id_lang_code_get_with_http_info(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        lang_code: Annotated[StrictStr, Field(description="Language code of the article")],
        is_for_display: Annotated[StrictBool | None, Field(description="Set this to true, if you are displaying the article to the end-user. If true, the content of snippets or variables appears in the article. Note: If the value is true, ensure that the article content is not passed for update article endpoints.")] = None,
        is_published: Annotated[StrictBool | None, Field(description="**true** : You will get the latest published version of the article. (If there are no published versions, then it will return the latest version)              **false** : To get the the latest version of the article")] = None,
        append_sas_token: Annotated[StrictBool | None, Field(description="Set this to false to exclude appending SAS token for images/files")] = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetArticleResponseCustomer]:
        """Gets an article


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param lang_code: Language code of the article (required)
        :type lang_code: str
        :param is_for_display: Set this to true, if you are displaying the article to the end-user. If true, the content of snippets or variables appears in the article. Note: If the value is true, ensure that the article content is not passed for update article endpoints.
        :type is_for_display: bool
        :param is_published: **true** : You will get the latest published version of the article. (If there are no published versions, then it will return the latest version)              **false** : To get the the latest version of the article
        :type is_published: bool
        :param append_sas_token: Set this to false to exclude appending SAS token for images/files
        :type append_sas_token: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_article_id_lang_code_get_serialize(
            article_id=article_id,
            lang_code=lang_code,
            is_for_display=is_for_display,
            is_published=is_published,
            append_sas_token=append_sas_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "GetArticleResponseCustomer",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def v2_articles_article_id_lang_code_get_without_preload_content(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        lang_code: Annotated[StrictStr, Field(description="Language code of the article")],
        is_for_display: Annotated[StrictBool | None, Field(description="Set this to true, if you are displaying the article to the end-user. If true, the content of snippets or variables appears in the article. Note: If the value is true, ensure that the article content is not passed for update article endpoints.")] = None,
        is_published: Annotated[StrictBool | None, Field(description="**true** : You will get the latest published version of the article. (If there are no published versions, then it will return the latest version)              **false** : To get the the latest version of the article")] = None,
        append_sas_token: Annotated[StrictBool | None, Field(description="Set this to false to exclude appending SAS token for images/files")] = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Gets an article


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param lang_code: Language code of the article (required)
        :type lang_code: str
        :param is_for_display: Set this to true, if you are displaying the article to the end-user. If true, the content of snippets or variables appears in the article. Note: If the value is true, ensure that the article content is not passed for update article endpoints.
        :type is_for_display: bool
        :param is_published: **true** : You will get the latest published version of the article. (If there are no published versions, then it will return the latest version)              **false** : To get the the latest version of the article
        :type is_published: bool
        :param append_sas_token: Set this to false to exclude appending SAS token for images/files
        :type append_sas_token: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_article_id_lang_code_get_serialize(
            article_id=article_id,
            lang_code=lang_code,
            is_for_display=is_for_display,
            is_published=is_published,
            append_sas_token=append_sas_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "GetArticleResponseCustomer",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_articles_article_id_lang_code_get_serialize(
        self,
        article_id,
        lang_code,
        is_for_display,
        is_published,
        append_sas_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if article_id is not None:
            _path_params["articleId"] = article_id
        if lang_code is not None:
            _path_params["langCode"] = lang_code
        # process the query parameters
        if is_for_display is not None:

            _query_params.append(("isForDisplay", is_for_display))

        if is_published is not None:

            _query_params.append(("isPublished", is_published))

        if append_sas_token is not None:

            _query_params.append(("appendSASToken", append_sas_token))

        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                [
                    "application/json"
                ]
            )


        # authentication setting
        _auth_settings: list[str] = [
            "api_token"
        ]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/v2/Articles/{articleId}/{langCode}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def v2_articles_article_id_lang_code_publish_post(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        lang_code: Annotated[StrictStr, Field(description="Language code of the article")],
        publish_article_request: PublishArticleRequest | None = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CreateArticleResponse:
        """Publishes an article with an id


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param lang_code: Language code of the article (required)
        :type lang_code: str
        :param publish_article_request: 
        :type publish_article_request: PublishArticleRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_article_id_lang_code_publish_post_serialize(
            article_id=article_id,
            lang_code=lang_code,
            publish_article_request=publish_article_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CreateArticleResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def v2_articles_article_id_lang_code_publish_post_with_http_info(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        lang_code: Annotated[StrictStr, Field(description="Language code of the article")],
        publish_article_request: PublishArticleRequest | None = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CreateArticleResponse]:
        """Publishes an article with an id


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param lang_code: Language code of the article (required)
        :type lang_code: str
        :param publish_article_request: 
        :type publish_article_request: PublishArticleRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_article_id_lang_code_publish_post_serialize(
            article_id=article_id,
            lang_code=lang_code,
            publish_article_request=publish_article_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CreateArticleResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def v2_articles_article_id_lang_code_publish_post_without_preload_content(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        lang_code: Annotated[StrictStr, Field(description="Language code of the article")],
        publish_article_request: PublishArticleRequest | None = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Publishes an article with an id


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param lang_code: Language code of the article (required)
        :type lang_code: str
        :param publish_article_request: 
        :type publish_article_request: PublishArticleRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_article_id_lang_code_publish_post_serialize(
            article_id=article_id,
            lang_code=lang_code,
            publish_article_request=publish_article_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CreateArticleResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_articles_article_id_lang_code_publish_post_serialize(
        self,
        article_id,
        lang_code,
        publish_article_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if article_id is not None:
            _path_params["articleId"] = article_id
        if lang_code is not None:
            _path_params["langCode"] = lang_code
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if publish_article_request is not None:
            _body_params = publish_article_request


        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                [
                    "application/json"
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        "application/json-patch+json",
                        "application/json",
                        "text/json",
                        "application/*+json"
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: list[str] = [
            "api_token"
        ]

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/v2/Articles/{articleId}/{langCode}/publish",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def v2_articles_article_id_lang_code_put(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        lang_code: Annotated[StrictStr, Field(description="Language code of the article")],
        update_article_request: UpdateArticleRequest | None = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CreateArticleResponse:
        """Updates an article with the ID


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param lang_code: Language code of the article (required)
        :type lang_code: str
        :param update_article_request: 
        :type update_article_request: UpdateArticleRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_article_id_lang_code_put_serialize(
            article_id=article_id,
            lang_code=lang_code,
            update_article_request=update_article_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CreateArticleResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def v2_articles_article_id_lang_code_put_with_http_info(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        lang_code: Annotated[StrictStr, Field(description="Language code of the article")],
        update_article_request: UpdateArticleRequest | None = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CreateArticleResponse]:
        """Updates an article with the ID


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param lang_code: Language code of the article (required)
        :type lang_code: str
        :param update_article_request: 
        :type update_article_request: UpdateArticleRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_article_id_lang_code_put_serialize(
            article_id=article_id,
            lang_code=lang_code,
            update_article_request=update_article_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CreateArticleResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def v2_articles_article_id_lang_code_put_without_preload_content(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        lang_code: Annotated[StrictStr, Field(description="Language code of the article")],
        update_article_request: UpdateArticleRequest | None = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Updates an article with the ID


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param lang_code: Language code of the article (required)
        :type lang_code: str
        :param update_article_request: 
        :type update_article_request: UpdateArticleRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_article_id_lang_code_put_serialize(
            article_id=article_id,
            lang_code=lang_code,
            update_article_request=update_article_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CreateArticleResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_articles_article_id_lang_code_put_serialize(
        self,
        article_id,
        lang_code,
        update_article_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if article_id is not None:
            _path_params["articleId"] = article_id
        if lang_code is not None:
            _path_params["langCode"] = lang_code
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if update_article_request is not None:
            _body_params = update_article_request


        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                [
                    "application/json"
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        "application/json-patch+json",
                        "application/json",
                        "text/json",
                        "application/*+json"
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: list[str] = [
            "api_token"
        ]

        return self.api_client.param_serialize(
            method="PUT",
            resource_path="/v2/Articles/{articleId}/{langCode}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def v2_articles_article_id_lang_code_settings_get(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        lang_code: Annotated[StrictStr, Field(description="Language code of the article")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetArticleSettingsResponse:
        """Gets settings for the article


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param lang_code: Language code of the article (required)
        :type lang_code: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_article_id_lang_code_settings_get_serialize(
            article_id=article_id,
            lang_code=lang_code,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "GetArticleSettingsResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def v2_articles_article_id_lang_code_settings_get_with_http_info(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        lang_code: Annotated[StrictStr, Field(description="Language code of the article")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetArticleSettingsResponse]:
        """Gets settings for the article


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param lang_code: Language code of the article (required)
        :type lang_code: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_article_id_lang_code_settings_get_serialize(
            article_id=article_id,
            lang_code=lang_code,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "GetArticleSettingsResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def v2_articles_article_id_lang_code_settings_get_without_preload_content(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        lang_code: Annotated[StrictStr, Field(description="Language code of the article")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Gets settings for the article


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param lang_code: Language code of the article (required)
        :type lang_code: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_article_id_lang_code_settings_get_serialize(
            article_id=article_id,
            lang_code=lang_code,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "GetArticleSettingsResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_articles_article_id_lang_code_settings_get_serialize(
        self,
        article_id,
        lang_code,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if article_id is not None:
            _path_params["articleId"] = article_id
        if lang_code is not None:
            _path_params["langCode"] = lang_code
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                [
                    "application/json"
                ]
            )


        # authentication setting
        _auth_settings: list[str] = [
            "api_token"
        ]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/v2/Articles/{articleId}/{langCode}/settings",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def v2_articles_article_id_lang_code_settings_put(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        lang_code: Annotated[StrictStr, Field(description="Language code of the article")],
        update_article_settings_request: UpdateArticleSettingsRequest | None = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> UpdateArticleSettingsResponseCustomer:
        """Updates settings for the article


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param lang_code: Language code of the article (required)
        :type lang_code: str
        :param update_article_settings_request: 
        :type update_article_settings_request: UpdateArticleSettingsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_article_id_lang_code_settings_put_serialize(
            article_id=article_id,
            lang_code=lang_code,
            update_article_settings_request=update_article_settings_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "UpdateArticleSettingsResponseCustomer",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def v2_articles_article_id_lang_code_settings_put_with_http_info(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        lang_code: Annotated[StrictStr, Field(description="Language code of the article")],
        update_article_settings_request: UpdateArticleSettingsRequest | None = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[UpdateArticleSettingsResponseCustomer]:
        """Updates settings for the article


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param lang_code: Language code of the article (required)
        :type lang_code: str
        :param update_article_settings_request: 
        :type update_article_settings_request: UpdateArticleSettingsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_article_id_lang_code_settings_put_serialize(
            article_id=article_id,
            lang_code=lang_code,
            update_article_settings_request=update_article_settings_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "UpdateArticleSettingsResponseCustomer",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def v2_articles_article_id_lang_code_settings_put_without_preload_content(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        lang_code: Annotated[StrictStr, Field(description="Language code of the article")],
        update_article_settings_request: UpdateArticleSettingsRequest | None = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Updates settings for the article


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param lang_code: Language code of the article (required)
        :type lang_code: str
        :param update_article_settings_request: 
        :type update_article_settings_request: UpdateArticleSettingsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_article_id_lang_code_settings_put_serialize(
            article_id=article_id,
            lang_code=lang_code,
            update_article_settings_request=update_article_settings_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "UpdateArticleSettingsResponseCustomer",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_articles_article_id_lang_code_settings_put_serialize(
        self,
        article_id,
        lang_code,
        update_article_settings_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if article_id is not None:
            _path_params["articleId"] = article_id
        if lang_code is not None:
            _path_params["langCode"] = lang_code
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if update_article_settings_request is not None:
            _body_params = update_article_settings_request


        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                [
                    "application/json"
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        "application/json-patch+json",
                        "application/json",
                        "text/json",
                        "application/*+json"
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: list[str] = [
            "api_token"
        ]

        return self.api_client.param_serialize(
            method="PUT",
            resource_path="/v2/Articles/{articleId}/{langCode}/settings",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def v2_articles_article_id_lang_code_update_description_put(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        lang_code: Annotated[StrictStr, Field(description="Language code of the article")],
        description: Annotated[Annotated[str, Field(strict=True, max_length=250)] | None, Field(description="The description of the article")] = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CustomerApiBaseResponse:
        """Update the Article Description


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param lang_code: Language code of the article (required)
        :type lang_code: str
        :param description: The description of the article
        :type description: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_article_id_lang_code_update_description_put_serialize(
            article_id=article_id,
            lang_code=lang_code,
            description=description,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CustomerApiBaseResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def v2_articles_article_id_lang_code_update_description_put_with_http_info(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        lang_code: Annotated[StrictStr, Field(description="Language code of the article")],
        description: Annotated[Annotated[str, Field(strict=True, max_length=250)] | None, Field(description="The description of the article")] = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CustomerApiBaseResponse]:
        """Update the Article Description


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param lang_code: Language code of the article (required)
        :type lang_code: str
        :param description: The description of the article
        :type description: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_article_id_lang_code_update_description_put_serialize(
            article_id=article_id,
            lang_code=lang_code,
            description=description,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CustomerApiBaseResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def v2_articles_article_id_lang_code_update_description_put_without_preload_content(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        lang_code: Annotated[StrictStr, Field(description="Language code of the article")],
        description: Annotated[Annotated[str, Field(strict=True, max_length=250)] | None, Field(description="The description of the article")] = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update the Article Description


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param lang_code: Language code of the article (required)
        :type lang_code: str
        :param description: The description of the article
        :type description: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_article_id_lang_code_update_description_put_serialize(
            article_id=article_id,
            lang_code=lang_code,
            description=description,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CustomerApiBaseResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_articles_article_id_lang_code_update_description_put_serialize(
        self,
        article_id,
        lang_code,
        description,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if article_id is not None:
            _path_params["articleId"] = article_id
        if lang_code is not None:
            _path_params["langCode"] = lang_code
        # process the query parameters
        if description is not None:

            _query_params.append(("description", description))

        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                [
                    "application/json"
                ]
            )


        # authentication setting
        _auth_settings: list[str] = [
            "api_token"
        ]

        return self.api_client.param_serialize(
            method="PUT",
            resource_path="/v2/Articles/{articleId}/{langCode}/updateDescription",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def v2_articles_article_id_lang_code_version_version_number_delete(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        version_number: Annotated[StrictInt, Field(description="Version number of the article")],
        lang_code: Annotated[StrictStr, Field(description="Language code of the article")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CustomerApiBaseResponse:
        """Deletes an article version


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param version_number: Version number of the article (required)
        :type version_number: int
        :param lang_code: Language code of the article (required)
        :type lang_code: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_article_id_lang_code_version_version_number_delete_serialize(
            article_id=article_id,
            version_number=version_number,
            lang_code=lang_code,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CustomerApiBaseResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def v2_articles_article_id_lang_code_version_version_number_delete_with_http_info(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        version_number: Annotated[StrictInt, Field(description="Version number of the article")],
        lang_code: Annotated[StrictStr, Field(description="Language code of the article")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CustomerApiBaseResponse]:
        """Deletes an article version


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param version_number: Version number of the article (required)
        :type version_number: int
        :param lang_code: Language code of the article (required)
        :type lang_code: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_article_id_lang_code_version_version_number_delete_serialize(
            article_id=article_id,
            version_number=version_number,
            lang_code=lang_code,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CustomerApiBaseResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def v2_articles_article_id_lang_code_version_version_number_delete_without_preload_content(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        version_number: Annotated[StrictInt, Field(description="Version number of the article")],
        lang_code: Annotated[StrictStr, Field(description="Language code of the article")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Deletes an article version


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param version_number: Version number of the article (required)
        :type version_number: int
        :param lang_code: Language code of the article (required)
        :type lang_code: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_article_id_lang_code_version_version_number_delete_serialize(
            article_id=article_id,
            version_number=version_number,
            lang_code=lang_code,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CustomerApiBaseResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_articles_article_id_lang_code_version_version_number_delete_serialize(
        self,
        article_id,
        version_number,
        lang_code,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if article_id is not None:
            _path_params["articleId"] = article_id
        if version_number is not None:
            _path_params["versionNumber"] = version_number
        if lang_code is not None:
            _path_params["langCode"] = lang_code
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                [
                    "application/json"
                ]
            )


        # authentication setting
        _auth_settings: list[str] = [
            "api_token"
        ]

        return self.api_client.param_serialize(
            method="DELETE",
            resource_path="/v2/Articles/{articleId}/{langCode}/version/{versionNumber}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def v2_articles_article_id_lang_code_versions_get(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        lang_code: StrictStr,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetArticleVersionsResponse:
        """Gets all article versions


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param lang_code: (required)
        :type lang_code: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_article_id_lang_code_versions_get_serialize(
            article_id=article_id,
            lang_code=lang_code,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "GetArticleVersionsResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def v2_articles_article_id_lang_code_versions_get_with_http_info(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        lang_code: StrictStr,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetArticleVersionsResponse]:
        """Gets all article versions


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param lang_code: (required)
        :type lang_code: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_article_id_lang_code_versions_get_serialize(
            article_id=article_id,
            lang_code=lang_code,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "GetArticleVersionsResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def v2_articles_article_id_lang_code_versions_get_without_preload_content(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        lang_code: StrictStr,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Gets all article versions


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param lang_code: (required)
        :type lang_code: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_article_id_lang_code_versions_get_serialize(
            article_id=article_id,
            lang_code=lang_code,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "GetArticleVersionsResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_articles_article_id_lang_code_versions_get_serialize(
        self,
        article_id,
        lang_code,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if article_id is not None:
            _path_params["articleId"] = article_id
        if lang_code is not None:
            _path_params["langCode"] = lang_code
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                [
                    "application/json"
                ]
            )


        # authentication setting
        _auth_settings: list[str] = [
            "api_token"
        ]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/v2/Articles/{articleId}/{langCode}/versions",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def v2_articles_article_id_lang_code_versions_version_number_get(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        version_number: Annotated[StrictInt, Field(description="Version number of the article")],
        lang_code: Annotated[StrictStr, Field(description="Language code of the article")],
        is_for_display: Annotated[StrictBool | None, Field(description="Set this to true, if you are displaying the article to the end-user. If true, the content of snippets or variables appears in the article. Note: If the value is true, ensure that the article content is not passed for update article endpoints.")] = None,
        append_sas_token: Annotated[StrictBool | None, Field(description="Set this to false to exclude appending SAS token for images/files")] = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetArticleVersionResponse:
        """Gets article by a version number


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param version_number: Version number of the article (required)
        :type version_number: int
        :param lang_code: Language code of the article (required)
        :type lang_code: str
        :param is_for_display: Set this to true, if you are displaying the article to the end-user. If true, the content of snippets or variables appears in the article. Note: If the value is true, ensure that the article content is not passed for update article endpoints.
        :type is_for_display: bool
        :param append_sas_token: Set this to false to exclude appending SAS token for images/files
        :type append_sas_token: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_article_id_lang_code_versions_version_number_get_serialize(
            article_id=article_id,
            version_number=version_number,
            lang_code=lang_code,
            is_for_display=is_for_display,
            append_sas_token=append_sas_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "GetArticleVersionResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def v2_articles_article_id_lang_code_versions_version_number_get_with_http_info(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        version_number: Annotated[StrictInt, Field(description="Version number of the article")],
        lang_code: Annotated[StrictStr, Field(description="Language code of the article")],
        is_for_display: Annotated[StrictBool | None, Field(description="Set this to true, if you are displaying the article to the end-user. If true, the content of snippets or variables appears in the article. Note: If the value is true, ensure that the article content is not passed for update article endpoints.")] = None,
        append_sas_token: Annotated[StrictBool | None, Field(description="Set this to false to exclude appending SAS token for images/files")] = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetArticleVersionResponse]:
        """Gets article by a version number


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param version_number: Version number of the article (required)
        :type version_number: int
        :param lang_code: Language code of the article (required)
        :type lang_code: str
        :param is_for_display: Set this to true, if you are displaying the article to the end-user. If true, the content of snippets or variables appears in the article. Note: If the value is true, ensure that the article content is not passed for update article endpoints.
        :type is_for_display: bool
        :param append_sas_token: Set this to false to exclude appending SAS token for images/files
        :type append_sas_token: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_article_id_lang_code_versions_version_number_get_serialize(
            article_id=article_id,
            version_number=version_number,
            lang_code=lang_code,
            is_for_display=is_for_display,
            append_sas_token=append_sas_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "GetArticleVersionResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def v2_articles_article_id_lang_code_versions_version_number_get_without_preload_content(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        version_number: Annotated[StrictInt, Field(description="Version number of the article")],
        lang_code: Annotated[StrictStr, Field(description="Language code of the article")],
        is_for_display: Annotated[StrictBool | None, Field(description="Set this to true, if you are displaying the article to the end-user. If true, the content of snippets or variables appears in the article. Note: If the value is true, ensure that the article content is not passed for update article endpoints.")] = None,
        append_sas_token: Annotated[StrictBool | None, Field(description="Set this to false to exclude appending SAS token for images/files")] = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Gets article by a version number


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param version_number: Version number of the article (required)
        :type version_number: int
        :param lang_code: Language code of the article (required)
        :type lang_code: str
        :param is_for_display: Set this to true, if you are displaying the article to the end-user. If true, the content of snippets or variables appears in the article. Note: If the value is true, ensure that the article content is not passed for update article endpoints.
        :type is_for_display: bool
        :param append_sas_token: Set this to false to exclude appending SAS token for images/files
        :type append_sas_token: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_article_id_lang_code_versions_version_number_get_serialize(
            article_id=article_id,
            version_number=version_number,
            lang_code=lang_code,
            is_for_display=is_for_display,
            append_sas_token=append_sas_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "GetArticleVersionResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_articles_article_id_lang_code_versions_version_number_get_serialize(
        self,
        article_id,
        version_number,
        lang_code,
        is_for_display,
        append_sas_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if article_id is not None:
            _path_params["articleId"] = article_id
        if version_number is not None:
            _path_params["versionNumber"] = version_number
        if lang_code is not None:
            _path_params["langCode"] = lang_code
        # process the query parameters
        if is_for_display is not None:

            _query_params.append(("isForDisplay", is_for_display))

        if append_sas_token is not None:

            _query_params.append(("appendSASToken", append_sas_token))

        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                [
                    "application/json"
                ]
            )


        # authentication setting
        _auth_settings: list[str] = [
            "api_token"
        ]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/v2/Articles/{articleId}/{langCode}/versions/{versionNumber}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def v2_articles_article_id_publish_post(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        publish_article_request: PublishArticleRequest | None = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CreateArticleResponse:
        """(Deprecated) Publishes an article with an id


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param publish_article_request: 
        :type publish_article_request: PublishArticleRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """
        warnings.warn("POST /v2/Articles/{articleId}/publish is deprecated.", DeprecationWarning)

        _param = self._v2_articles_article_id_publish_post_serialize(
            article_id=article_id,
            publish_article_request=publish_article_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CreateArticleResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def v2_articles_article_id_publish_post_with_http_info(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        publish_article_request: PublishArticleRequest | None = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CreateArticleResponse]:
        """(Deprecated) Publishes an article with an id


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param publish_article_request: 
        :type publish_article_request: PublishArticleRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """
        warnings.warn("POST /v2/Articles/{articleId}/publish is deprecated.", DeprecationWarning)

        _param = self._v2_articles_article_id_publish_post_serialize(
            article_id=article_id,
            publish_article_request=publish_article_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CreateArticleResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def v2_articles_article_id_publish_post_without_preload_content(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        publish_article_request: PublishArticleRequest | None = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) Publishes an article with an id


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param publish_article_request: 
        :type publish_article_request: PublishArticleRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """
        warnings.warn("POST /v2/Articles/{articleId}/publish is deprecated.", DeprecationWarning)

        _param = self._v2_articles_article_id_publish_post_serialize(
            article_id=article_id,
            publish_article_request=publish_article_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CreateArticleResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_articles_article_id_publish_post_serialize(
        self,
        article_id,
        publish_article_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if article_id is not None:
            _path_params["articleId"] = article_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if publish_article_request is not None:
            _body_params = publish_article_request


        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                [
                    "application/json"
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        "application/json-patch+json",
                        "application/json",
                        "text/json",
                        "application/*+json"
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: list[str] = [
            "api_token"
        ]

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/v2/Articles/{articleId}/publish",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def v2_articles_article_id_settings_get(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetArticleSettingsResponse:
        """(Deprecated) Gets settings for the article


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """
        warnings.warn("GET /v2/Articles/{articleId}/settings is deprecated.", DeprecationWarning)

        _param = self._v2_articles_article_id_settings_get_serialize(
            article_id=article_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "GetArticleSettingsResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def v2_articles_article_id_settings_get_with_http_info(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetArticleSettingsResponse]:
        """(Deprecated) Gets settings for the article


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """
        warnings.warn("GET /v2/Articles/{articleId}/settings is deprecated.", DeprecationWarning)

        _param = self._v2_articles_article_id_settings_get_serialize(
            article_id=article_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "GetArticleSettingsResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def v2_articles_article_id_settings_get_without_preload_content(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) Gets settings for the article


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """
        warnings.warn("GET /v2/Articles/{articleId}/settings is deprecated.", DeprecationWarning)

        _param = self._v2_articles_article_id_settings_get_serialize(
            article_id=article_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "GetArticleSettingsResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_articles_article_id_settings_get_serialize(
        self,
        article_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if article_id is not None:
            _path_params["articleId"] = article_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                [
                    "application/json"
                ]
            )


        # authentication setting
        _auth_settings: list[str] = [
            "api_token"
        ]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/v2/Articles/{articleId}/settings",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def v2_articles_article_id_settings_put(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        update_article_settings_request: UpdateArticleSettingsRequest | None = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> UpdateArticleSettingsResponseCustomer:
        """(Deprecated) Updates settings for the article


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param update_article_settings_request: 
        :type update_article_settings_request: UpdateArticleSettingsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """
        warnings.warn("PUT /v2/Articles/{articleId}/settings is deprecated.", DeprecationWarning)

        _param = self._v2_articles_article_id_settings_put_serialize(
            article_id=article_id,
            update_article_settings_request=update_article_settings_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "UpdateArticleSettingsResponseCustomer",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def v2_articles_article_id_settings_put_with_http_info(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        update_article_settings_request: UpdateArticleSettingsRequest | None = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[UpdateArticleSettingsResponseCustomer]:
        """(Deprecated) Updates settings for the article


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param update_article_settings_request: 
        :type update_article_settings_request: UpdateArticleSettingsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """
        warnings.warn("PUT /v2/Articles/{articleId}/settings is deprecated.", DeprecationWarning)

        _param = self._v2_articles_article_id_settings_put_serialize(
            article_id=article_id,
            update_article_settings_request=update_article_settings_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "UpdateArticleSettingsResponseCustomer",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def v2_articles_article_id_settings_put_without_preload_content(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        update_article_settings_request: UpdateArticleSettingsRequest | None = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) Updates settings for the article


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param update_article_settings_request: 
        :type update_article_settings_request: UpdateArticleSettingsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """
        warnings.warn("PUT /v2/Articles/{articleId}/settings is deprecated.", DeprecationWarning)

        _param = self._v2_articles_article_id_settings_put_serialize(
            article_id=article_id,
            update_article_settings_request=update_article_settings_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "UpdateArticleSettingsResponseCustomer",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_articles_article_id_settings_put_serialize(
        self,
        article_id,
        update_article_settings_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if article_id is not None:
            _path_params["articleId"] = article_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if update_article_settings_request is not None:
            _body_params = update_article_settings_request


        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                [
                    "application/json"
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        "application/json-patch+json",
                        "application/json",
                        "text/json",
                        "application/*+json"
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: list[str] = [
            "api_token"
        ]

        return self.api_client.param_serialize(
            method="PUT",
            resource_path="/v2/Articles/{articleId}/settings",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def v2_articles_article_id_update_description_put(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        description: Annotated[Annotated[str, Field(strict=True, max_length=250)] | None, Field(description="The description of the article")] = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CustomerApiBaseResponse:
        """(Deprecated) Update the Article Description


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param description: The description of the article
        :type description: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """
        warnings.warn("PUT /v2/Articles/{articleId}/updateDescription is deprecated.", DeprecationWarning)

        _param = self._v2_articles_article_id_update_description_put_serialize(
            article_id=article_id,
            description=description,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CustomerApiBaseResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def v2_articles_article_id_update_description_put_with_http_info(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        description: Annotated[Annotated[str, Field(strict=True, max_length=250)] | None, Field(description="The description of the article")] = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CustomerApiBaseResponse]:
        """(Deprecated) Update the Article Description


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param description: The description of the article
        :type description: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """
        warnings.warn("PUT /v2/Articles/{articleId}/updateDescription is deprecated.", DeprecationWarning)

        _param = self._v2_articles_article_id_update_description_put_serialize(
            article_id=article_id,
            description=description,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CustomerApiBaseResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def v2_articles_article_id_update_description_put_without_preload_content(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        description: Annotated[Annotated[str, Field(strict=True, max_length=250)] | None, Field(description="The description of the article")] = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) Update the Article Description


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param description: The description of the article
        :type description: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """
        warnings.warn("PUT /v2/Articles/{articleId}/updateDescription is deprecated.", DeprecationWarning)

        _param = self._v2_articles_article_id_update_description_put_serialize(
            article_id=article_id,
            description=description,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CustomerApiBaseResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_articles_article_id_update_description_put_serialize(
        self,
        article_id,
        description,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if article_id is not None:
            _path_params["articleId"] = article_id
        # process the query parameters
        if description is not None:

            _query_params.append(("description", description))

        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                [
                    "application/json"
                ]
            )


        # authentication setting
        _auth_settings: list[str] = [
            "api_token"
        ]

        return self.api_client.param_serialize(
            method="PUT",
            resource_path="/v2/Articles/{articleId}/updateDescription",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def v2_articles_article_id_version_version_number_delete(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        version_number: Annotated[StrictInt, Field(description="Version number of the article")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CustomerApiBaseResponse:
        """(Deprecated) Deletes an article version


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param version_number: Version number of the article (required)
        :type version_number: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """
        warnings.warn("DELETE /v2/Articles/{articleId}/version/{versionNumber} is deprecated.", DeprecationWarning)

        _param = self._v2_articles_article_id_version_version_number_delete_serialize(
            article_id=article_id,
            version_number=version_number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CustomerApiBaseResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def v2_articles_article_id_version_version_number_delete_with_http_info(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        version_number: Annotated[StrictInt, Field(description="Version number of the article")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CustomerApiBaseResponse]:
        """(Deprecated) Deletes an article version


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param version_number: Version number of the article (required)
        :type version_number: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """
        warnings.warn("DELETE /v2/Articles/{articleId}/version/{versionNumber} is deprecated.", DeprecationWarning)

        _param = self._v2_articles_article_id_version_version_number_delete_serialize(
            article_id=article_id,
            version_number=version_number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CustomerApiBaseResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def v2_articles_article_id_version_version_number_delete_without_preload_content(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        version_number: Annotated[StrictInt, Field(description="Version number of the article")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) Deletes an article version


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param version_number: Version number of the article (required)
        :type version_number: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """
        warnings.warn("DELETE /v2/Articles/{articleId}/version/{versionNumber} is deprecated.", DeprecationWarning)

        _param = self._v2_articles_article_id_version_version_number_delete_serialize(
            article_id=article_id,
            version_number=version_number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CustomerApiBaseResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_articles_article_id_version_version_number_delete_serialize(
        self,
        article_id,
        version_number,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if article_id is not None:
            _path_params["articleId"] = article_id
        if version_number is not None:
            _path_params["versionNumber"] = version_number
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                [
                    "application/json"
                ]
            )


        # authentication setting
        _auth_settings: list[str] = [
            "api_token"
        ]

        return self.api_client.param_serialize(
            method="DELETE",
            resource_path="/v2/Articles/{articleId}/version/{versionNumber}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def v2_articles_article_id_versions_get(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetArticleVersionsResponse:
        """(Deprecated) Gets all article versions


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """
        warnings.warn("GET /v2/Articles/{articleId}/versions is deprecated.", DeprecationWarning)

        _param = self._v2_articles_article_id_versions_get_serialize(
            article_id=article_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "GetArticleVersionsResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def v2_articles_article_id_versions_get_with_http_info(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetArticleVersionsResponse]:
        """(Deprecated) Gets all article versions


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """
        warnings.warn("GET /v2/Articles/{articleId}/versions is deprecated.", DeprecationWarning)

        _param = self._v2_articles_article_id_versions_get_serialize(
            article_id=article_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "GetArticleVersionsResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def v2_articles_article_id_versions_get_without_preload_content(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) Gets all article versions


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """
        warnings.warn("GET /v2/Articles/{articleId}/versions is deprecated.", DeprecationWarning)

        _param = self._v2_articles_article_id_versions_get_serialize(
            article_id=article_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "GetArticleVersionsResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_articles_article_id_versions_get_serialize(
        self,
        article_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if article_id is not None:
            _path_params["articleId"] = article_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                [
                    "application/json"
                ]
            )


        # authentication setting
        _auth_settings: list[str] = [
            "api_token"
        ]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/v2/Articles/{articleId}/versions",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def v2_articles_article_id_versions_version_number_get(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        version_number: Annotated[StrictInt, Field(description="Version number of the article")],
        is_for_display: Annotated[StrictBool | None, Field(description="Set this to true, if you are displaying the article to the end-user. If true, the content of snippets or variables appears in the article. Note: If the value is true, ensure that the article content is not passed for update article endpoints.")] = None,
        append_sas_token: Annotated[StrictBool | None, Field(description="Set this to false to exclude appending SAS token for images/files")] = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetArticleVersionResponse:
        """(Deprecated) Gets article by a version number


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param version_number: Version number of the article (required)
        :type version_number: int
        :param is_for_display: Set this to true, if you are displaying the article to the end-user. If true, the content of snippets or variables appears in the article. Note: If the value is true, ensure that the article content is not passed for update article endpoints.
        :type is_for_display: bool
        :param append_sas_token: Set this to false to exclude appending SAS token for images/files
        :type append_sas_token: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """
        warnings.warn("GET /v2/Articles/{articleId}/versions/{versionNumber} is deprecated.", DeprecationWarning)

        _param = self._v2_articles_article_id_versions_version_number_get_serialize(
            article_id=article_id,
            version_number=version_number,
            is_for_display=is_for_display,
            append_sas_token=append_sas_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "GetArticleVersionResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def v2_articles_article_id_versions_version_number_get_with_http_info(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        version_number: Annotated[StrictInt, Field(description="Version number of the article")],
        is_for_display: Annotated[StrictBool | None, Field(description="Set this to true, if you are displaying the article to the end-user. If true, the content of snippets or variables appears in the article. Note: If the value is true, ensure that the article content is not passed for update article endpoints.")] = None,
        append_sas_token: Annotated[StrictBool | None, Field(description="Set this to false to exclude appending SAS token for images/files")] = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetArticleVersionResponse]:
        """(Deprecated) Gets article by a version number


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param version_number: Version number of the article (required)
        :type version_number: int
        :param is_for_display: Set this to true, if you are displaying the article to the end-user. If true, the content of snippets or variables appears in the article. Note: If the value is true, ensure that the article content is not passed for update article endpoints.
        :type is_for_display: bool
        :param append_sas_token: Set this to false to exclude appending SAS token for images/files
        :type append_sas_token: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """
        warnings.warn("GET /v2/Articles/{articleId}/versions/{versionNumber} is deprecated.", DeprecationWarning)

        _param = self._v2_articles_article_id_versions_version_number_get_serialize(
            article_id=article_id,
            version_number=version_number,
            is_for_display=is_for_display,
            append_sas_token=append_sas_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "GetArticleVersionResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def v2_articles_article_id_versions_version_number_get_without_preload_content(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        version_number: Annotated[StrictInt, Field(description="Version number of the article")],
        is_for_display: Annotated[StrictBool | None, Field(description="Set this to true, if you are displaying the article to the end-user. If true, the content of snippets or variables appears in the article. Note: If the value is true, ensure that the article content is not passed for update article endpoints.")] = None,
        append_sas_token: Annotated[StrictBool | None, Field(description="Set this to false to exclude appending SAS token for images/files")] = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) Gets article by a version number


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param version_number: Version number of the article (required)
        :type version_number: int
        :param is_for_display: Set this to true, if you are displaying the article to the end-user. If true, the content of snippets or variables appears in the article. Note: If the value is true, ensure that the article content is not passed for update article endpoints.
        :type is_for_display: bool
        :param append_sas_token: Set this to false to exclude appending SAS token for images/files
        :type append_sas_token: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """
        warnings.warn("GET /v2/Articles/{articleId}/versions/{versionNumber} is deprecated.", DeprecationWarning)

        _param = self._v2_articles_article_id_versions_version_number_get_serialize(
            article_id=article_id,
            version_number=version_number,
            is_for_display=is_for_display,
            append_sas_token=append_sas_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "GetArticleVersionResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_articles_article_id_versions_version_number_get_serialize(
        self,
        article_id,
        version_number,
        is_for_display,
        append_sas_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if article_id is not None:
            _path_params["articleId"] = article_id
        if version_number is not None:
            _path_params["versionNumber"] = version_number
        # process the query parameters
        if is_for_display is not None:

            _query_params.append(("isForDisplay", is_for_display))

        if append_sas_token is not None:

            _query_params.append(("appendSASToken", append_sas_token))

        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                [
                    "application/json"
                ]
            )


        # authentication setting
        _auth_settings: list[str] = [
            "api_token"
        ]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/v2/Articles/{articleId}/versions/{versionNumber}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def v2_articles_bulkcreate_post(
        self,
        create_article_request: list[CreateArticleRequest] | None = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BulkCreateArticleResponseCustomer:
        """Adds multiple articles


        :param create_article_request: 
        :type create_article_request: List[CreateArticleRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_bulkcreate_post_serialize(
            create_article_request=create_article_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "BulkCreateArticleResponseCustomer",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def v2_articles_bulkcreate_post_with_http_info(
        self,
        create_article_request: list[CreateArticleRequest] | None = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BulkCreateArticleResponseCustomer]:
        """Adds multiple articles


        :param create_article_request: 
        :type create_article_request: List[CreateArticleRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_bulkcreate_post_serialize(
            create_article_request=create_article_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "BulkCreateArticleResponseCustomer",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def v2_articles_bulkcreate_post_without_preload_content(
        self,
        create_article_request: list[CreateArticleRequest] | None = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Adds multiple articles


        :param create_article_request: 
        :type create_article_request: List[CreateArticleRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_bulkcreate_post_serialize(
            create_article_request=create_article_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "BulkCreateArticleResponseCustomer",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_articles_bulkcreate_post_serialize(
        self,
        create_article_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
            "CreateArticleRequest": "",
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if create_article_request is not None:
            _body_params = create_article_request


        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                [
                    "application/json"
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        "application/json-patch+json",
                        "application/json",
                        "text/json",
                        "application/*+json"
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: list[str] = [
            "api_token"
        ]

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/v2/Articles/bulkcreate",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def v2_articles_bulkdelete_article_versions_delete(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        lang_code: Annotated[StrictStr, Field(description="Language code of the article")],
        article_version_numbers: Annotated[list[StrictInt], Field(description="Array of article version numbers")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BulkDeleteArticleVersionResonse:
        """Delete multiple article versions


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param lang_code: Language code of the article (required)
        :type lang_code: str
        :param article_version_numbers: Array of article version numbers (required)
        :type article_version_numbers: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_bulkdelete_article_versions_delete_serialize(
            article_id=article_id,
            lang_code=lang_code,
            article_version_numbers=article_version_numbers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "BulkDeleteArticleVersionResonse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def v2_articles_bulkdelete_article_versions_delete_with_http_info(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        lang_code: Annotated[StrictStr, Field(description="Language code of the article")],
        article_version_numbers: Annotated[list[StrictInt], Field(description="Array of article version numbers")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BulkDeleteArticleVersionResonse]:
        """Delete multiple article versions


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param lang_code: Language code of the article (required)
        :type lang_code: str
        :param article_version_numbers: Array of article version numbers (required)
        :type article_version_numbers: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_bulkdelete_article_versions_delete_serialize(
            article_id=article_id,
            lang_code=lang_code,
            article_version_numbers=article_version_numbers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "BulkDeleteArticleVersionResonse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def v2_articles_bulkdelete_article_versions_delete_without_preload_content(
        self,
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        lang_code: Annotated[StrictStr, Field(description="Language code of the article")],
        article_version_numbers: Annotated[list[StrictInt], Field(description="Array of article version numbers")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete multiple article versions


        :param article_id: The ID of the article (required)
        :type article_id: str
        :param lang_code: Language code of the article (required)
        :type lang_code: str
        :param article_version_numbers: Array of article version numbers (required)
        :type article_version_numbers: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_bulkdelete_article_versions_delete_serialize(
            article_id=article_id,
            lang_code=lang_code,
            article_version_numbers=article_version_numbers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "BulkDeleteArticleVersionResonse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_articles_bulkdelete_article_versions_delete_serialize(
        self,
        article_id,
        lang_code,
        article_version_numbers,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
            "articleVersionNumbers": "multi",
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        # process the query parameters
        if article_id is not None:

            _query_params.append(("articleId", article_id))

        if lang_code is not None:

            _query_params.append(("langCode", lang_code))

        if article_version_numbers is not None:

            _query_params.append(("articleVersionNumbers", article_version_numbers))

        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                [
                    "application/json"
                ]
            )


        # authentication setting
        _auth_settings: list[str] = [
            "api_token"
        ]

        return self.api_client.param_serialize(
            method="DELETE",
            resource_path="/v2/Articles/bulkdelete-article-versions",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def v2_articles_bulkdelete_delete(
        self,
        article_ids: Annotated[list[StrictStr], Field(description="Array of article IDs")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BulkDeleteArticleResponse:
        """Deletes multiple articles


        :param article_ids: Array of article IDs (required)
        :type article_ids: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_bulkdelete_delete_serialize(
            article_ids=article_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "BulkDeleteArticleResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def v2_articles_bulkdelete_delete_with_http_info(
        self,
        article_ids: Annotated[list[StrictStr], Field(description="Array of article IDs")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BulkDeleteArticleResponse]:
        """Deletes multiple articles


        :param article_ids: Array of article IDs (required)
        :type article_ids: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_bulkdelete_delete_serialize(
            article_ids=article_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "BulkDeleteArticleResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def v2_articles_bulkdelete_delete_without_preload_content(
        self,
        article_ids: Annotated[list[StrictStr], Field(description="Array of article IDs")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Deletes multiple articles


        :param article_ids: Array of article IDs (required)
        :type article_ids: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_bulkdelete_delete_serialize(
            article_ids=article_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "BulkDeleteArticleResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_articles_bulkdelete_delete_serialize(
        self,
        article_ids,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
            "articleIds": "multi",
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        # process the query parameters
        if article_ids is not None:

            _query_params.append(("articleIds", article_ids))

        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                [
                    "application/json"
                ]
            )


        # authentication setting
        _auth_settings: list[str] = [
            "api_token"
        ]

        return self.api_client.param_serialize(
            method="DELETE",
            resource_path="/v2/Articles/bulkdelete",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def v2_articles_bulkpublish_lang_code_post(
        self,
        lang_code: Annotated[StrictStr, Field(description="Language code of the article")],
        bulk_publish_article: list[BulkPublishArticle] | None = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CreateArticleResponse:
        """Publishes multiple articles


        :param lang_code: Language code of the article (required)
        :type lang_code: str
        :param bulk_publish_article: 
        :type bulk_publish_article: List[BulkPublishArticle]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_bulkpublish_lang_code_post_serialize(
            lang_code=lang_code,
            bulk_publish_article=bulk_publish_article,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CreateArticleResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def v2_articles_bulkpublish_lang_code_post_with_http_info(
        self,
        lang_code: Annotated[StrictStr, Field(description="Language code of the article")],
        bulk_publish_article: list[BulkPublishArticle] | None = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CreateArticleResponse]:
        """Publishes multiple articles


        :param lang_code: Language code of the article (required)
        :type lang_code: str
        :param bulk_publish_article: 
        :type bulk_publish_article: List[BulkPublishArticle]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_bulkpublish_lang_code_post_serialize(
            lang_code=lang_code,
            bulk_publish_article=bulk_publish_article,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CreateArticleResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def v2_articles_bulkpublish_lang_code_post_without_preload_content(
        self,
        lang_code: Annotated[StrictStr, Field(description="Language code of the article")],
        bulk_publish_article: list[BulkPublishArticle] | None = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Publishes multiple articles


        :param lang_code: Language code of the article (required)
        :type lang_code: str
        :param bulk_publish_article: 
        :type bulk_publish_article: List[BulkPublishArticle]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_bulkpublish_lang_code_post_serialize(
            lang_code=lang_code,
            bulk_publish_article=bulk_publish_article,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CreateArticleResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_articles_bulkpublish_lang_code_post_serialize(
        self,
        lang_code,
        bulk_publish_article,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
            "BulkPublishArticle": "",
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if lang_code is not None:
            _path_params["langCode"] = lang_code
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if bulk_publish_article is not None:
            _body_params = bulk_publish_article


        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                [
                    "application/json"
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        "application/json-patch+json",
                        "application/json",
                        "text/json",
                        "application/*+json"
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: list[str] = [
            "api_token"
        ]

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/v2/Articles/bulkpublish/{langCode}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def v2_articles_bulkupdate_put(
        self,
        bulk_update_article: list[BulkUpdateArticle] | None = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BulkUpdateArticleResponse:
        """Updates multiple articles


        :param bulk_update_article: 
        :type bulk_update_article: List[BulkUpdateArticle]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_bulkupdate_put_serialize(
            bulk_update_article=bulk_update_article,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "BulkUpdateArticleResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def v2_articles_bulkupdate_put_with_http_info(
        self,
        bulk_update_article: list[BulkUpdateArticle] | None = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BulkUpdateArticleResponse]:
        """Updates multiple articles


        :param bulk_update_article: 
        :type bulk_update_article: List[BulkUpdateArticle]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_bulkupdate_put_serialize(
            bulk_update_article=bulk_update_article,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "BulkUpdateArticleResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def v2_articles_bulkupdate_put_without_preload_content(
        self,
        bulk_update_article: list[BulkUpdateArticle] | None = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Updates multiple articles


        :param bulk_update_article: 
        :type bulk_update_article: List[BulkUpdateArticle]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_bulkupdate_put_serialize(
            bulk_update_article=bulk_update_article,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "BulkUpdateArticleResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_articles_bulkupdate_put_serialize(
        self,
        bulk_update_article,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
            "BulkUpdateArticle": "",
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if bulk_update_article is not None:
            _body_params = bulk_update_article


        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                [
                    "application/json"
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        "application/json-patch+json",
                        "application/json",
                        "text/json",
                        "application/*+json"
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: list[str] = [
            "api_token"
        ]

        return self.api_client.param_serialize(
            method="PUT",
            resource_path="/v2/Articles/bulkupdate",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def v2_articles_post(
        self,
        create_article_request: CreateArticleRequest | None = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CreateArticleResponse:
        """Adds an article to an existing category


        :param create_article_request: 
        :type create_article_request: CreateArticleRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_post_serialize(
            create_article_request=create_article_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CreateArticleResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def v2_articles_post_with_http_info(
        self,
        create_article_request: CreateArticleRequest | None = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CreateArticleResponse]:
        """Adds an article to an existing category


        :param create_article_request: 
        :type create_article_request: CreateArticleRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_post_serialize(
            create_article_request=create_article_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CreateArticleResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def v2_articles_post_without_preload_content(
        self,
        create_article_request: CreateArticleRequest | None = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Adds an article to an existing category


        :param create_article_request: 
        :type create_article_request: CreateArticleRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_articles_post_serialize(
            create_article_request=create_article_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CreateArticleResponse",
            "400": "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_articles_post_serialize(
        self,
        create_article_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if create_article_request is not None:
            _body_params = create_article_request


        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                [
                    "application/json"
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        "application/json-patch+json",
                        "application/json",
                        "text/json",
                        "application/*+json"
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: list[str] = [
            "api_token"
        ]

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/v2/Articles",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


